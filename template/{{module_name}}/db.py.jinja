"""
Database connection and user/file management for PostgreSQL.

This module provides the database layer for {{ project_name }}, handling:
- User authentication and management
- File metadata storage and retrieval
- Database migrations
- Connection pooling with asyncpg
"""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

import asyncpg  # type: ignore
from asyncpg import Pool  # type: ignore

from {{ module_name }}.db_utils import hash_password, verify_password

# Configure logging
logger = logging.getLogger(__name__)


class Database:
    """PostgreSQL database connection and operations manager."""

    def __init__(self, database_url: str):
        self.database_url = database_url
        self.pool: Optional[Pool] = None

    async def connect(self) -> None:
        """Create connection pool to PostgreSQL."""
        self.pool = await asyncpg.create_pool(
            self.database_url,
            min_size=5,
            max_size=20,
            command_timeout=60
        )
        logger.info("Database connection pool created")

    async def disconnect(self) -> None:
        """Close connection pool."""
        if self.pool:
            await self.pool.close()
            logger.info("Database connection pool closed")

    async def init_db(self) -> None:
        """Initialize database - runs migrations and seeding on startup."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        # Step 1: Run schema migrations
        from {{ module_name }}.db_migrate import migrate_database

        await migrate_database(self.pool)
        logger.info("Database migrations completed")

        # Step 2: Run data seeding (admin user, etc.)
        from {{ module_name }}.db_seed import ensure_admin_user

        async with self.pool.acquire() as conn:
            await ensure_admin_user(conn)

        logger.info("Database initialized (migrations + seeding complete)")

    # ==================== Password Management ====================
    # Note: Password utilities are now in db_utils.py to avoid duplication

    # ==================== User Management ====================

    async def create_user(
        self,
        email: str,
        password: str,
        role: str = "user",
        status: str = "active",
        full_name: Optional[str] = None,
        company_name: Optional[str] = None,
    ) -> int:
        """Create a new user and return their ID."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        password_hash = hash_password(password)

        async with self.pool.acquire() as conn:
            try:
                user_id = await conn.fetchval(
                    """
                    INSERT INTO users (
                        email, password_hash, role, status,
                        full_name, company_name, created_at, updated_at
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                    RETURNING id
                    """,
                    email, password_hash, role, status, full_name, company_name
                )
                logger.info(f"Created user: {email} (ID: {user_id})")
                return user_id
            except asyncpg.UniqueViolationError:
                raise ValueError(f"User with email {email} already exists")

    async def get_user_by_email(self, email: str) -> Optional[Dict[str, Any]]:
        """Get user by email address."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, email, password_hash, role, status,
                       full_name, company_name, created_at, updated_at
                FROM users
                WHERE email = $1
                """,
                email
            )
            return dict(row) if row else None

    async def get_user_by_id(self, user_id: int) -> Optional[Dict[str, Any]]:
        """Get user by ID."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, email, password_hash, role, status,
                       full_name, company_name, created_at, updated_at
                FROM users
                WHERE id = $1
                """,
                user_id
            )
            return dict(row) if row else None

    async def authenticate_user(self, email: str, password: str) -> Optional[Dict[str, Any]]:
        """Authenticate user with email and password."""
        user = await self.get_user_by_email(email)
        if not user:
            return None

        if not verify_password(password, user["password_hash"]):
            return None

        if user["status"] != "active":
            return None

        return user

    async def update_user(self, user_id: int, **fields) -> bool:
        """Update user fields."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        # Handle password hashing if password is being updated
        if "password" in fields:
            fields["password_hash"] = hash_password(fields.pop("password"))

        # Build dynamic UPDATE query
        allowed_fields = {
            "email", "password_hash", "role", "status",
            "full_name", "company_name"
        }

        updates = []
        values = []
        idx = 1

        for field, value in fields.items():
            if field in allowed_fields:
                updates.append(f"{field} = ${idx}")
                values.append(value)
                idx += 1

        if not updates:
            return False

        updates.append(f"updated_at = ${idx}")
        values.append(datetime.now())
        values.append(user_id)

        query = f"""
            UPDATE users
            SET {', '.join(updates)}
            WHERE id = ${idx + 1}
        """

        async with self.pool.acquire() as conn:
            result = await conn.execute(query, *values)
            return result == "UPDATE 1"

    async def delete_user(self, user_id: int) -> bool:
        """Delete a user and their associated data."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            async with conn.transaction():
                # Delete user's files first (foreign key constraint)
                await conn.execute(
                    "UPDATE files SET uploaded_by = NULL WHERE uploaded_by = $1",
                    user_id
                )

                # Delete the user
                result = await conn.execute(
                    "DELETE FROM users WHERE id = $1",
                    user_id
                )
                return result == "DELETE 1"

    async def list_users(
        self,
        limit: int = 100,
        offset: int = 0,
        role: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """List users with pagination."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        query = """
            SELECT id, email, role, status, full_name, company_name,
                   created_at, updated_at,
                   (SELECT COUNT(*) FROM files WHERE uploaded_by = users.id) as file_count
            FROM users
        """

        params = []
        where_clauses = []
        param_idx = 1

        if role:
            where_clauses.append(f"role = ${param_idx}")
            params.append(role)
            param_idx += 1

        if where_clauses:
            query += " WHERE " + " AND ".join(where_clauses)

        query += f" ORDER BY created_at DESC LIMIT ${param_idx} OFFSET ${param_idx + 1}"
        params.extend([limit, offset])

        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
            return [dict(row) for row in rows]

    async def get_user_count(self, role: Optional[str] = None) -> int:
        """Get total count of users."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        query = "SELECT COUNT(*) FROM users"
        params = []

        if role:
            query += " WHERE role = $1"
            params.append(role)

        async with self.pool.acquire() as conn:
            count = await conn.fetchval(query, *params) if params else await conn.fetchval(query)
            return count or 0

    # ==================== File Management ====================

    async def create_file_record(
        self,
        filename: str,
        original_filename: str,
        content_type: str,
        file_size: int,
        file_data: bytes,
        uploaded_by: Optional[int] = None
    ) -> int:
        """Create a file record and store file data."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            file_id = await conn.fetchval(
                """
                INSERT INTO files (
                    filename, original_filename, content_type,
                    file_size, data, uploaded_by, created_at
                )
                VALUES ($1, $2, $3, $4, $5, $6, NOW())
                RETURNING id
                """,
                filename, original_filename, content_type,
                file_size, file_data, uploaded_by
            )
            logger.info(f"Created file record: {filename} (ID: {file_id})")
            return file_id

    async def get_file_by_id(self, file_id: int) -> Optional[Dict[str, Any]]:
        """Get file metadata and data by ID."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT f.*, u.email as uploader_email
                FROM files f
                LEFT JOIN users u ON f.uploaded_by = u.id
                WHERE f.id = $1 AND f.is_active = TRUE
                """,
                file_id
            )
            return dict(row) if row else None

    async def get_file_by_filename(self, filename: str) -> Optional[Dict[str, Any]]:
        """Get file metadata and data by filename."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT f.*, u.email as uploader_email
                FROM files f
                LEFT JOIN users u ON f.uploaded_by = u.id
                WHERE f.filename = $1 AND f.is_active = TRUE
                """,
                filename
            )
            return dict(row) if row else None

    async def list_files(
        self,
        limit: int = 100,
        offset: int = 0,
        uploaded_by: Optional[int] = None,
        search: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """List files with pagination and optional filters."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        query = """
            SELECT f.id, f.filename, f.original_filename, f.content_type,
                   f.file_size, f.uploaded_by, f.created_at,
                   u.email as uploader_email, u.full_name as uploader_name
            FROM files f
            LEFT JOIN users u ON f.uploaded_by = u.id
            WHERE f.is_active = TRUE
        """

        params = []
        param_idx = 1

        if uploaded_by:
            query += f" AND f.uploaded_by = ${param_idx}"
            params.append(uploaded_by)
            param_idx += 1

        if search:
            query += f" AND (f.original_filename ILIKE ${param_idx} OR u.email ILIKE ${param_idx})"
            params.append(f"%{search}%")
            param_idx += 1

        query += f" ORDER BY f.created_at DESC LIMIT ${param_idx} OFFSET ${param_idx + 1}"
        params.extend([limit, offset])

        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
            return [dict(row) for row in rows]

    async def get_file_count(
        self,
        uploaded_by: Optional[int] = None,
        search: Optional[str] = None
    ) -> int:
        """Get total count of files."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        query = """
            SELECT COUNT(*)
            FROM files f
            LEFT JOIN users u ON f.uploaded_by = u.id
            WHERE f.is_active = TRUE
        """

        params = []
        param_idx = 1

        if uploaded_by:
            query += f" AND f.uploaded_by = ${param_idx}"
            params.append(uploaded_by)
            param_idx += 1

        if search:
            query += f" AND (f.original_filename ILIKE ${param_idx} OR u.email ILIKE ${param_idx})"
            params.append(f"%{search}%")
            param_idx += 1

        async with self.pool.acquire() as conn:
            count = await conn.fetchval(query, *params)
            return count or 0

    async def delete_file(self, file_id: int) -> bool:
        """Soft delete a file (mark as inactive)."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            result = await conn.execute(
                "UPDATE files SET is_active = FALSE WHERE id = $1",
                file_id
            )
            return result == "UPDATE 1"

    async def get_unique_filename(self, base_filename: str) -> str:
        """Generate a unique filename by adding suffix if needed."""
        if not self.pool:
            raise RuntimeError("Database not connected")

        async with self.pool.acquire() as conn:
            # Check if filename exists
            exists = await conn.fetchval(
                "SELECT COUNT(*) FROM files WHERE filename = $1",
                base_filename
            )

            if not exists:
                return base_filename

            # Generate unique filename with suffix
            name_parts = base_filename.rsplit('.', 1)
            base_name = name_parts[0]
            extension = name_parts[1] if len(name_parts) > 1 else ""

            counter = 1
            while True:
                new_filename = f"{base_name}_{counter:03d}"
                if extension:
                    new_filename = f"{new_filename}.{extension}"

                exists = await conn.fetchval(
                    "SELECT COUNT(*) FROM files WHERE filename = $1",
                    new_filename
                )

                if not exists:
                    return new_filename

                counter += 1
                if counter > 999:
                    raise ValueError("Cannot generate unique filename")


# Global database instance
_db_instance: Optional[Database] = None


def get_db() -> Database:
    """Get the global database instance."""
    if _db_instance is None:
        raise RuntimeError("Database not initialized")
    return _db_instance


def init_db(database_url: str) -> None:
    """Initialize global database instance."""
    global _db_instance
    _db_instance = Database(database_url)


async def setup_database(database_url: str) -> None:
    """Set up database connection and initialize tables."""
    init_db(database_url)
    db = get_db()
    await db.connect()
    await db.init_db()
