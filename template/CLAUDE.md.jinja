# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important Documentation Files
- **Design & Vision**: `docs/design.md` - User stories, page structure, and movement philosophy
- **Technical Requirements**: `docs/requirements.md` - Tech stack, data models, and security requirements
- **Development Progress**: `docs/todos.md` - Phased implementation roadmap and current status
## Working with spec-kit
- if the command /specify /plan or /task is used, have a look at
  files: README.md docs/design.md docs/requirements.md docs/todos.md - you may find all the hints you need.
  
## for your coding practice, there are some important rules:
1. Start by analysing features and document the feature and update the documentation.
   Features get a name and the place to document them are here:
   `docs/features_concepts/<feature_name>.md`
2. implement tests (for the backend - not the frontend!)
3. implement the feature - carefully decide to create DRY modules. In doubt, read:
   file `CLAUDE_BBS.md` - do not over-engineer. BUT CREATE REUSABLE COMPONENTS. BBS style.
4. ASSUME THE SERVER IS RUNNING, when you want to check for backend logic with curl
   Tell me, if it is not running.
   You always assume that there is an server.log file that is written to by the server running by the command:
   `uv run uvicorn {{ module_name }}.main:app --reload --port 8877 2>&1 | tee server.log`
   You may read the current last log entries by something like:
   file server.log # that you may read with:
   `tail -n 300 server.log`
5. run all tests (with `uv run pytest` or even more intense `./check.sh`)
6. iterate on the feature until tests are running and user is satisfied
7. if feature is implemented: 
   update the docs
   then git commit (or ask the user to do so)

## Development Commands

### Quick Development
```bash

# start backend with, writing logs to file server.log
# ALWAYS ASSUME, THIS IS RUNNING - if NOT ASK USER TO START THIS MANUALLY
uv run uvicorn {{ module_name }}.main:app --reload --port 8877 2>&1 | tee server.log

# Run application with auto-reload on port 8877
# DONT USE THAT WITH CLAUDE - ony use it if server logs are not important to read by claude code
uv run uvicorn {{ module_name }}.main:app --reload --port 8877

# Run all tests
uv run pytest

# Run comprehensive quality checks (formatting, linting, type checking, tests)
./check.sh

# Watch tests during development
uv run pytest-watch

# For debugging: claude will be able to read server logs
# in file server.log with command 
tail -n 300 server.log

```

### Package Management
- Use `uv add <package>` to install new dependencies
- Use `uv sync` to sync dependencies
- Use `uv remove <package>` to remove packages
- **NEVER** use pip directly - always use uv

### Quality Assurance Pipeline
```bash
# Complete development pipeline (runs in this order):
./check.sh  # Executes:
1. uv run black .          # Code formatting
2. ruff check --fix .      # Linting with auto-fix
3. mypy .                 # Type checking
4. uv run pytest          # All tests
5. pytest                 # All tests, shorter

# Always run ./check.sh before committing changes
```

### Database Operations
```bash
# Start fresh database (destructive - drops all tables)
# DO THAT ONLY, WHEN USER TELLS TO DELETE / DROP the database! OTHERWISE: DONT!
DROP_TABLES_BEFORE_INIT=true uv run uvicorn {{ module_name }}.main:app --reload --port 8877

```

### Deployment to fly.io
```bash

# Deploy to test environment
./fly_deploy_test.sh

# Deploy to production
./fly_deploy_prod.sh
```

## Architecture Overview

### Core Components & Black Box Boundaries

#### 1. **Application Layer** (`{{ module_name }}/main.py`)
- **Primary Interface**: FastAPI application with rate limiting, CORS, and HTML templates
- **Authentication**: JWT-based auth with role-based access control (admin/user/visitor)
- **Visitor Access**: Public file browsing and download without authentication
- **Optional Auth**: `get_optional_current_user()` allows endpoints to work for both authenticated users and visitors
- **Rate Limiting**: Configurable limits per endpoint using slowapi
- **HTML Rendering**: Jinja2 templates for mobile-responsive web interface
- **File Integration**: Static file serving and upload endpoints

#### 2. **File Management System** (`{{ module_name }}/upload_files.py`)
- **Black Box**: Complete file upload/download system with PostgreSQL BYTEA storage
- **Features**: Unique filename generation, intelligent thumbnail creation (`image_SMALL.jpg`), file type validation
- **Thumbnail System**: Automatic thumbnail generation for images with `_SMALL` suffix naming
- **Architecture**: Files stored in database with metadata, not filesystem
- **Interface**: FileService class with upload/download/list/delete operations
- **Security**: File size limits (10MB), content type validation, user ownership

#### 3. **Database Layer** (`{{ module_name }}/db.py`)
- **Black Box**: PostgreSQL connection pool with async operations
- **Interface**: Clean API for users/companies/events/files management
- **Features**: Connection pooling, password hashing, table initialization
- **Migration System**: `db_migrate.py` handles schema evolution with backup/restore
- **Replaceable**: Could swap PostgreSQL for another database by implementing same interface

#### 4. **Data Models** (`{{ module_name }}/models.py`)
- **Primitives**: User, File schemas
- **Validation**: Pydantic models with comprehensive field validation
- **Security**: Separation of internal vs public data models
- **API Response Handling**: Special handling for datetime serialization

#### 5. **Configuration Management** (`{{ module_name }}/config.py`)
- **Black Box**: Centralized settings with Pydantic BaseSettings
- **Priority System**: .env file > shell environment > defaults (via `settings_customise_sources`)
- **Startup Logging**: Shows configuration sources and DATABASE_URL at startup
- **Interface**: Environment variables with sensible defaults
- **Security**: Secret key management and admin password synchronization

### Key Architectural Patterns

#### Black Box Design Principles
- **Database Layer**: Complete abstraction - implementation details hidden behind clean API
- **Authentication**: Modular JWT implementation - could be replaced with OAuth2
- **Configuration**: Environment-agnostic settings management

#### Data Flow Primitives
- **User Data**: email, role, status, full_name, phone, company details, about sections, portrait_url
- **File Data**: filename, original_filename, content_type, file_size, data (BYTEA), thumbnail_type
- **Authentication**: JWT tokens with email and role claims

#### Interface Contracts
- **Database Interface**: Consistent async methods for CRUD operations with datetime handling
- **API Endpoints**: RESTful design with proper HTTP status codes and datetime serialization
- **Template Context**: Standardized context objects with computed fields for all pages

### Security Architecture
- **Role-Based Access**: admin, user, visitor hierarchy
- **Visitor Access**: Unauthenticated users can browse and download files
- **Optional Authentication**: Endpoints use `get_optional_current_user()` for visitor support
- **Password Hashing**: bcrypt with passlib context
- **JWT Tokens**: HS256 algorithm with configurable expiration (30 days default)
- **Environment Master**: ADMIN_PASSWORD environment variable controls admin access
- **Rate Limiting**: Per-endpoint configurable limits
- **Config Priority**: .env file always overrides shell environment variables


### Development Guidelines (from .cursor/rules)
- **Pure Functions**: Write functions without side effects
- **Type Safety**: Use Pydantic for all data validation
- **DRY Principle**: Factor out common code and values
- **API Design**: Clear, documented interfaces for all components
- **Testing**: Write tests for all new features
- **Code Quality**: Run `./check.sh` after implementing features
- **File Size**: Split files when they exceed 300 lines
- **Line Length**: Maximum 78 characters per line


### MCP Server Integration
- **context7**: Library documentation retrieval
- **PostgreSQL MCP**: Database operations and query execution

Setup commands for MCP servers are documented in README.md.


---

**Remember**: This system follows Black Box Design principles. Each module should be replaceable using only its public interface. Focus on maintaining clean boundaries between components.
- You should assume that the server is running. Don't start it or ask the user to start it. The code is reloaded automatically!
- Practical Perspective: Acknowledges this is a hobby project with ~100 users and ~1000 files, not an
  enterprise system